# bemforjs.ru.md

В БЭМ-методологии JavaScript используется для «оживления» веб-страницы и рассматривается как одна из [технологий реализации](../key-concepts/key-concepts.ru.md#Технология-реализации) блока.

Как и к любой другой технологии (например, CSS) к JavaScript применяются основыные принципы компонентного подхода:

* Единая предметная область
* Разделение кода на части
	* Принцип инкапсуляции
	* Принцип наследования
* Работа с уровнями переопределения и использование сборки

Особенности реализации JavaScript по БЭМ-методологии рассмотриваются в следующих разделах:

* Работа блоками
	* Взаимодействие блоков
	* Взаимодействие блока с его элементами
	* Работа с модификаторами
	* Реакция на изменение модификаторов

* Представление динамических блоков в DOM
	* Блоки с DOM-представлением
	* Блоки без DOM-представления

* Принципы ООП в JavaScript по БЭМ
	* Инкапсуляция
	* Наследование


## Единая предметная область

В БЭМ для работы с JavaScript используются термины «Блок», «Элемент» и «Модификатор».

JavaScript-реализация блоков не привязывается к DOM-элементам страницы, а использует следующий уровень абстракции — [БЭМ-дерево](../key-concepts/key-concepts.ru.md#БЭМ-дерево). Это позволяет не опираться на классы и независимо описывать поведение блоков и их опциональных элементов.

Поведение блоков и элементов задается с помощью модификаторов. По аналогии с CSS, где модификатор определяет внешний вид блока, в JavaScript установка/снятие модификатора изменяет поведение блока. 

Использование единой предметной области дает возможность на более высоком уровне взаимодействовать с компонентами:
* реализовать различные хелперы для работы с компонентами;
* отказаться от жесткого кодирования имен блоков и разделителей. 

На практике это позволяет находить внутри блока все элементы с определенным именем и выставлять им модификатор, проверять его значение. 

**Пример**

Необходимо показать всплывающее окно (блок `popup`).

Один из наиболее распространенных способов – добавить соответствующий класс и жестко прописать имя блока в коде, а это не всегда удобно. 

```js
document.querySelector('.button')
.addEventListener('click', function() {
  document.querySelector('.popup').classList.toggle('popup_visible');
}, false);
```

В БЭМ-проекте поиск компонента выполняется по классу, а по имени блока, так как имя блока уникально, а сам компонент может выражаться не только классом, но и тегом, атрибутом и т.д. Отображение всплывающего окна также не зависит от класса: блок переводится в состояние `visible` с помощью модификатора. 

```js
block('button').click(function() {
  block('popup').toggleMod('visible');
});
```

> **Важно** Для примеров, написанных по БЭМ-методологии, используется псевдокод. Реальные примеры реализации представлены в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/v2/i-bem-js/).


## Разделение кода на части

В БЭМ-методологии поведение каждого блока описывается независимо.

К JavaScript применяются основные принципы организации и хранения кода:
* разделение кода на отдельные части — логика работы каждого блока, его опциональных элементов и модификаторов описывается в отдельных файлах;
* JavaScript-файлы для каждого компонента хранятся в соответствии с [правилами организации файловой структуры](../filestructure/filestructure.ru.md) БЭМ-проекта.

**Пример**

Рассмотрим пример логотипа (блок `logo`), реализованного в технологии CSS.

Блок `logo` в файловой структуре проекта:

```files
logo/			# Директория блока logo
    logo.css 	# Реализация блока logo в технологии CSS
``` 

Добавим блоку `logo` новую функциональность: нажатие на логотип вызывает какое-то действие. 

JavaScript-реализация блока:

```js
document.querySelector('.logo').addEventListener('click', doSomething, false);
```

Файл `logo.js` в файловой структуре блока `logo`:

```files
logo/			# Директория блока logo
    logo.css    # Реализация блока logo в технологии CSS
    logo.js     # Реализация блока logo в технологии JavaScript
```

Разделение кода на части и строгая организация файловой структуры проекта позволяют:

* облегчить навигацию по проекту;
* повторно использовать блоки;
* использовать уровни переопределения для технологии JavaScript.

#### Принцип инкапсуляции 

В БЭМ JavaScript-реализация одного блока отделена от другого. Каждый блок предоставляет API для [взаимодействия с другими блоками](#Взаимодействие-блоков).

Декларация блока позволяет скрыть его внутреннюю реализацию. Так как элементы всегда являются внутренней реализацией блока, [обращение к ним](#Взаимодействие-блока-с-его-элементами) возможно только через API самого блока.

#### Принцип наследования

Декларативное описание поведения блоков позволяет использовать методы базового блока внутри производного, наследовать их. Новый блок может получать все свойства и методы базового.

Также можно создавать цепочки наследования — блок наследуется от другого, который, в свою очередь, наследуется от третьего и т.д.

> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js-decl/#Наследование-блока).

### Работа с уровнями переопределения

Логика работы блока описывается декларативно: как набор действий и условий, при которых эти действия необходимо выполнять. Это позволяет разделять функциональность блока на отдельные части и использовать [уровни переопределения](../key-concepts/key-concepts.ru.md#Уровень-переопределения).

Разделение по уровням позволяет:

* реализовывать новое поведение блока на другом уровне переопределения, сохраняя предыдущее, наследовать и дополнять его (делать super call);
* полностью перекрывать поведение блока (переопределять);
* добавлять блоки с новым поведением.

С помощью уровней переопределения можно создать универсальную JavaScript-библиотеку блоков и изменять ее на проектном уровне. Затем использовать сборку и включать в проект только необходимое поведение блоков.

**Пример**

Рассмотрим пример формы отправки сообщения.

```js
block('button').onSetMod({
    focused: {
        true: this.onFocus,
        '': this.onBlur
    }
});
```

Запись в БЭМ-терминах позволяет на другом уровне переопределения:

* Полностью перекрывать поведение блока.

  ```js
  block('button').onSetMod({
      focused: {
          true: this.someCustomOnFocused  // Полное изменение поведение блока
      }
  });
  ```

* Добавлять или частично изменять поведение блока.

  ```js
  block('button').onSetMod({
      focused: {
          true: function() {
              this.__base.apply(this, arguments);	// Частичное изменение поведения блока
              this.someCustomOnFocused();
          }
      }
  });
  ```

> Для работы с JavaScript в БЭМ-терминах и использования уровней переопределения в БЭМ создан специализированный фреймворк [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js/).


## Работа с блоками, элементами и модификаторами

### Работа с модификаторами

Поведение блока описывается с помощью состояний. Состояния задаются с помощью модификаторов. Перевод блока в другое состояние производится при помощи установки/снятия модификатора. Изменение модификатора создает событие, которое можно использовать для работы с блоком.

Например, чтобы отметить чекбокс, блоку `checkbox` нужно установить модификатор `checked` в значение `true`.

В БЭМ-проекте нельзя изменять состояния в режиме runtime с помощью модификатора, напрямую меняя CSS-класс на соответствующем DOM-узле. Для корректной работы JavaScript все манипуляции с модификаторами должны производиться при помощи методов-хелперов.

> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js-mods/).

### Реакция на изменение модификаторов

Переход блока из одного состояния в другое часто сопровождается изменениями его внешнего вида. Если изменение состояния блока вызвано модификатором, в котором определен и внешний вид блока, то при установке этого модификатора измененится не только поведения блока, но и автоматически применятся новые стили. 

В БЭМ реакция на установку/снятие модификатора описывается декларативно: при изменении состояний автоматически вызывается код, который задекларирован для этого состояния. Так, например, если в CSS во время исполнения появляется какой-то дополнительный класс (модификатор), то все свойства этого модификатора автоматически применяются к DOM-узлу, на который этот класс установлен. В JavaScript происходит то же самое: если появляется модификатор (добавляется новый класс к DOM-узлу), то вся функциональность, свойственная этому модификатору, также применяется. Если модификатор исчезает, функциональность отключается.

Чтобы динамически изменять состояния блоков и элементов, используются специальные методы для установки и снятия модификаторов.

> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/v2/i-bem-js-mods/).

**Пример**

Рассмотрим форму отправки сообщения. Должно выполняться условие: если введен неправильный email, кнопка отправки (блок `button`) становится недоступна (получает модификатор `button_disabled`).

Можно жестко прописать все условия в коде и постоянно выполнять проверку. Такой подход не удобен, так как любое изменение потребует изменений в коде вручную.

В БЭМ-проекте можно задекларировать поведение блока и получить возможность перекрывать каждый модификатор отдельно на новом уровне переопределения. В [декларации](https://ru.bem.info/technology/i-bem/current/i-bem-js-decl/) можно указать, как блок или элемент должен отреагировать на изменение модификатора.

```js
block('button').onSetMod({
    focused: {
        true: this.onFocus,
        '': this.onBlur
    }
});
```

Такой подход дает возможность:
* Реагировать на модификатор независимо от способа его установки/снятия (через JavaScript API: `block('button').setMod('focused')` или пользователь установил/снял фокус курсором).
* Определять каждому состоянию свой внешний вид, добавив стили модификатору.
* Изменять или полностью перекрывать поведение блока с помощью [уровней переопределения](#Работа-с-уровнями-переопределения).

### Взаимодействие блоков

БЭМ-методология предполагает работу с независимыми блоками. Однако на практике полная независимость блоков недостижима.

Блоки могут взаимодействовать друг с другом с помощью:

* Подписки на события других экземпляров блоков.
* Подписки на изменения модификаторов.
* Непосредственного вызова методов других экземпляров блоков или статических методов класса другого блока.
* Любых паттернов взаимодействия. Например, канала событий: все коммуникации происходят благодаря сообщениям, которые компоненты публикуют и слушают с помощью посредника.

> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js-interaction/).

БЭМ-методология рекомендует выстраивать взаимодействие между блоками в иерархическом порядке в соответствии с их расположением в DOM-дереве. Вложенный блок не должен ничего знать о родительском блоке, так как это нарушает принцип независимости компонентов.

### Взаимодействие блока с его элементами

Элемент — это внутренняя реализация блока.
В БЭМ-методологии принято реализовывать дополнительные хелперы блока для работы с его элементами. Обращение напрямую к элементу другого блока невозможно. Взаимодействие с элементом происходит только через API блока, которому принадлежит данный элемент.

## Представление динамических блоков в DOM

### Блоки с DOM-представлением

Блокам с JavaScript-реализацией могут соответствовать узлы в HTML. В этом случае говорится о том, что **блоки имеют DOM-представление**.

В простейшем случае блок соответствует DOM-узлу один к одному. Однако DOM-узел и блок — это не всегда одно и то же. Можно разместить несколько блоков на одном DOM-узле (это называется [микс](../key-concepts/key-concepts.ru.md#Микс)), а также реализовать один блок на нескольких DOM-узлах.

### Блоки без DOM-представления

Инфраструктурный код, решающий общие задачи интерфейса (связь с бэкэндом, вспомогательные методы), может быть оформлен в виде блока без DOM-представления. Это позволит выражать состояния блока с помощью модификаторов, на изменение которых смогут подписаться другие блоки.

> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js-decl/#Синтаксис-декларации).



## Как перейти на JavaScript по БЭМ

Самый быстрый путь — начать применять принципы БЭМ-методологии в своем проекте и получать первые результаты без использования специализированного фреймворка. Как это сделать на практике показано в статье [БЭМ — это не только про CSS](https://ru.bem.info/forum/163/) с примерами на jQuery.

Чтобы реализовать сразу все идеи БЭМ в вашем проекте, необходимо:

* работать в [единых терминах](#Единая-предметная-область) блоков, элементов и модификаторов во всех технологиях;
* создавать независимые компоненты — блоки — на уровне JavaScript;
* изменять поведение блоков, элементов и модификаторов с помощью уровней переопределения по аналогии с CSS;
* повторно использовать блоки, переносить их между проектами;
* облегчить и ускорить разработку и отладку проекта за счет несвязанности компонентов и возможности разрабатывать поблочно;
* включать в сборку только нужную JavaScript-реализацию блока;
* облегчить навигацию по файловой структуре проекта.


